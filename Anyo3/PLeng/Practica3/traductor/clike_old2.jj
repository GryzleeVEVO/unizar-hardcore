//*****************************************************************
// File:   clike.jj
// Author: Wozniak, Dorian Boleslaw (817570@unizar.es)
// Author: Jaime Royo, Oscar (818961@unizar.es)
// Date:   15/03/2023
// Coms:   compilar mediante "ant". Solo implementa análisis léxico
//*****************************************************************

options {
    IGNORE_CASE = false;
    COMMON_TOKEN_ACTION = false;
    //DEBUG_PARSER = true;
    // ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;
import lib.attributes.Attributes;
import lib.tools.SemanticFunctions;
import lib.tools.exceptions.*;
import java.util.ArrayList;

public class clike {

    // Lista de palabras reservadas
    private static String[] reservadas = {
        "INT",
        "BOOL",
        "CHAR",
        "VOID",
        
        "IF",
        "ELSE",
        "WHILE",

        "RETURN"
    };

    // Tabla de símbolos
    public static SymbolTable st = new SymbolTable(reservadas);

    // Clase errores semánticos
    public static SemanticFunctions sf = new SemanticFunctions(st);


    public static void main(String[] args) {
        clike parser = null;
        
        try {
            if (args.length == 0) {
                parser = new clike(System.in);
            }
            else {
                parser = new clike(new java.io.FileInputStream(args[0]));
            }
            //Programa es el símbolo inicial de la gramática
            parser.Programa();
            System.out.println("***** Análisis terminado con éxito *****");
        }
        catch (java.io.FileNotFoundException e) {
            System.err.println ("Fichero " + args[0] + " no encontrado.");
        }
        catch (TokenMgrError e) {
            System.err.println("ERROR LÉXICO: " + e.getMessage());
        } 
        catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
    }
}
PARSER_END(clike)


/* ***** ANALIZADOR LÉXICO ***** */


// Tokens internos
TOKEN : { 
    < #LETTER: (["a"-"z","A"-"Z"]) > | 
    < #DIGIT: ["0"-"9"] > 
}

// Tokens generados
TOKEN : {

    /* --- PALABRAS RESERVADAS --- */

    // Tipos de datos básicos
    < tBOOL: "bool" > |
    < tCHAR: "char" > | 	
    < tINT: "int" > |
    < tVOID: "void" > |

    // Condicionales 	
    < tIF: "if"> |	
    < tELSE: "else" > |

    // Bucles	 	
    < tWHILE : "while" > |

    // Regreso
 	< tRETURN : "return"> |

    /* --- DELIMITADORES --- */

    // Paréntesis (guardas if/while, parametros funciones, expresiones...)
	< tPAREN_INI: "(" >

|	< tPAREN_FIN : ")" >

    // Llaves (delimitadores bloques)
| 	< tLLAVE_INI : "{" >

| 	< tLLAVE_FIN : "}" >

    // Corchetes (vectores)
| 	< tCORCH_INI : "[" >

| 	< tCORCH_FIN : "]" >

    // Separador de variables 
|	< tCOMA : "," > 
    
    // Fin de órden
|	< tPUNTO_COMA : ";" > 
    
    /* --- OPERADORES --- */

    // Asignación
|	< tASIGNAR : "=" > 
    
    // Aritmética
|	< tSUMA : "+" >

|	< tRESTA : "-" >

|	< tMULTI : "*" >

|	< tDIV : "/" >

|	< tMODULO : "%" >

    // Lógica 
|	< tMAYOR : ">" >

|	< tMENOR : "<" >

|	< tMAYOR_IGUAL: ">=" >

|	< tMENOR_IGUAL : "<=" >

|	< tIGUAL : "==" >

|	< tDISTINTO : "!=" >

| 	< tAND : "&&" >

| 	< tOR : "||" >

| 	< tNOT : "!" >

    // Referencia
|	< tAMPERSAND : "&" >

    /* --- FUNCIONES INTEGRADAS --- */

|	< tPRINT : "print" >

|	< tPRINT_LN : "print_ln" >

|	< tREAD : "read" >

|	< tREAD_LN : "read_ln" >

|	< tINT2CHAR : "int2char" >

|	< tCHAR2INT : "char2int" >

    /* --- IDENTIFICADORES --- */

|	< tIDENTIFICADOR : ( < LETTER > | "_")( < LETTER > | < DIGIT > | "_" )* >

    /* --- CONSTANTES SIMBÓLICAS --- */

|	< tCONST_CHAR : "'"(~[])"'" >

|	< tCONST_STRING : "\""(~["\""] | "\"\"")*"\"" >

|	< tCONST_NUM : ((< DIGIT >)+ ) >

|	< tTRUE : "true" >

|	< tFALSE : "false" > 
}

// Expresiones a ignorar
SKIP : {
    " " | "\t" | "\n" 						// Espacios en blanco
    | <tCOMENTARIO : ("//"(~["\n"])*) > 	// Comentarios
}

/* ***** ANÁLISIS SINTÁCTICO ***** */

/* DECLARACIÓN Y ASIGNACIÓN */

// Devuelve el tipo de dato de una declaración/parámetro
Symbol.Types tipo() : {} {
    <tINT>  { return Symbol.Types.INT; } | 
    <tCHAR> { return Symbol.Types.CHAR; } |
    <tBOOL> { return Symbol.Types.BOOL; }
}

// Devuelve el tamaño de la declaración de un vector
// La expresión debe ser un entero
Attributes array() : {
    Attributes term;
}
{
    <tCORCH_INI> 
    term = expresion()
    <tCORCH_FIN> {

        try {
            sf.checkTypes(term, Symbol.Types.INT)
        } catch (MismatchedTypesException e) {
            sf.deteccion(e);
        }
    }
}

// Crea un símbolo para un escalar/vector de nombre, tipo y clase dados
Symbol identificador(String name, Symbol.Types type, Symbol.ParameterClass pc) : {
    int size;
} {
    // Vectorial
    size = array() {
        return new SymbolArray(name, size, type, pc);
    } |
    // Escalar
    /* epsilon */ {          
        return sf.newSymbol(name, type, pc);
    } 
} 

// Genera un símbolo para una variable de una lista del tipo dado
void variable(Symbol.Types type) : {
    Symbol s;
    Token t;
} {  
    <tCOMA> 
    t = <tIDENTIFICADOR> 
    s = identificador(t.image, type, Symbol.ParameterClass.NONE) {
        sf.insertSymbol(s, t);
    } 
}

// Devuelve una lista de cero o mas parámetros
ArrayList<Symbol> lista_param() : {
    ArrayList<Symbol> param = new ArrayList<Symbol>();
    Symbol s;
} {
    (
        s = parametro() {
            param.add(s);
        } 
        ( 
            <tCOMA> 
            s = parametro() {
                param.add(s);
            }
        )*
    )? {
        return param;
    }
}  

// Devuelve el símbolo de un parámetro por valor o referencia
Symbol parametro() : {
    Symbol.Types type;
    Symbol s;
} {
    type = tipo()
    s = parametro_val_ref(type) {
        return s;
    }
}

// Desambigua y devuelve el símbolo de un parámetro por valor o referencia
Symbol parametro_val_ref(Symbol.Types type) : {
    Symbol s;
    Token t;
} {
    (
        (
            <tAMPERSAND>
            t = <tIDENTIFICADOR>
            s = identificador(t.image, type, Symbol.ParameterClass.REF)
        ) | 
        (
            t = <tIDENTIFICADOR>
            s = identificador(t.image, type, Symbol.ParameterClass.VAL) 
        )
    ) {
        return s;
    } 
}

// Una declaración de variables/procedimientos/funciones
void declaracion() : {
    Symbol.Types type;
    ArrayList<Symbol> param;
    Token t;
    Symbol s;
} {
    (   
        // Variable/función
        (        
            type = tipo()
            t = <tIDENTIFICADOR> 
            decl_var_fun(t, type) 
        ) |
        // Procedimientos
        (        
            <tVOID>
            t = <tIDENTIFICADOR>
            <tPAREN_INI>
            param = lista_param() {
                s = new SymbolProcedure(t.image, param);
                sf.insertSymbol(s, t);
                st.insertBlock();
            }
            <tPAREN_FIN>
            bloque()
        )
    )
    { System.err.println(st.toString()); }
}

void decl_var_fun(Token prev, Symbol.Types type) : {
    Symbol s;
    Token t;
    ArrayList<Symbol> param;
} {
    // Función
    (    
        <tPAREN_INI>
        param = lista_param()
        <tPAREN_FIN> {
            s = new SymbolFunction(prev.image, param, type);
            insertSymbol(s, prev);
            st.insertBlock();
        }
        bloque()
    ) |
    // Variables
    (    
        s = identificador(prev.image, type, Symbol.ParameterClass.NONE) {
            try {
                st.insertSymbol(s);
            } catch (AlreadyDefinedSymbolException e) {
                ErrorSemantico.deteccion(e, prev);
            }
        }
        ( variable(type) )*
        <tPUNTO_COMA>
    ) 
}

1

/* ---  PRODUCCIÓN INICIAL --- */
// void Programa() : {} { ( declaracion() )+ < EOF > }


void Programa() : {} { ( expresion() )+ <EOF> }

/* CÁLCULO DE EXPRESIONES */


// Contiene una lista de cero o más expresiones
void lista_expresiones() : {}
{
    ( lista_expresiones_cont() )?
}

// Contiene una lista de una o más expresiones
void lista_expresiones_cont() : {}
{
    expresion() (<tCOMA> expresion())*
}

// Expresión -> Prioridad 7
void expresion() : {
    Attributes term1, term2, ret;
}
{
    // Sin operador lógico -> Cualquier tipo
    term1 = relacion_aritmetica() {
        ret = term1;
    }
    // Con operador lógico -> Ambos operandos son booleanos
    (
        term2 = relacion_logica() {
            // TODO: Comprueba que term1 es booleano
        } 
    )?
}

// Relación lógica -> Prioridad 6 (comparaciones lógicas)
void relacion_logica() : {
    Attributes term;
} {
    // Los operandos deben ser booleanos
    (
        operador_logico()
        term = relacion_aritmetica() {
            // TODO: Comprueba que term es booleano
        }
    )+
}

// Relación aritmética -> Prioridad 5 (comparaciones aritméticas)
void relacion_aritmetica() : {
    Attributes term1, term2;
}
{
    // Sin operador relacional -> Cualquier tipo
    expresion_simple() 
    // Con operador relacional -> term1 y term2 deben ser del mismo tipo
    ( 
        operador_relacional() 
        expresion_simple() {
            // TODO: Comprueba que term1 y term2 sean del mismo tipo
        }
    )?
}
// Expresión simple -> Prioridad 4 (suma/resta)
void expresion_simple() : {
    Attributes term1, term2;
    boolean operador = false;
}
{
    // Prefijo operador -> Termino debe ser entero
    ( 
        operador_suma() {
            operador = true;
        }
    )? 
    // Sin prefijo -> Cualquier tipo
    term1 = termino() {
        // TODO: Si es operador, comprueba que term1 sea un entero
    }
    // Con operador suma/resta -> term1 y term2 deben ser enteros
    ( 
        operador_suma() 
        termino() {
            // TODO: term1 y term2 deben ser enteros
        } 
    )*
}

// Término -> Prioridad 3 (multiplicación/división/módulo)
Attributes termino() :  {
    Attributes term1, term2, ret;
}
{   
    // Sin operador multiplicación/división/módulo -> Cualquier tipo
    term1 = factor() {

    }
    // Con operador multiplicación/división/módulo -> Solo enteros
    ( 
        operador_multi() 
        term2 = factor()  {
            // TODO: term1 y term2 deben ser enteros
        }
    )* {

    }
}

// Factor -> Prioridad 2 (negación)
Attributes factor() : {
    Attributes term;
}
{
    ( 
        // Sin negación -> Cualquier tipo
        term = primario() |
        // Con negación -> Solo booleanos
        <tNOT> term = primario()
    )
}

// Primario -> Prioridad 1
Attributes primario() : {
    Attributes term;
    Token t;
    Symbol s;
} 
{
    // Paréntesis
    <tPAREN_INI> term = expresion() <tPAREN_FIN> {
        return term;
    } |
    // Constantes 
    t = <tCONST_NUM> {
        return new Attributes(Intger.parseInt(t.image));
    } |								
	<tCONST_CHAR> {
        return new Attributes(t.image[0]);
    } |
    <tCONST_STRING> {
        return new Attributes(t.image);
    } |
    <tTRUE> {
        return new Attributes(true);
    } |
    <tFALSE> {
        return new Attributes(false);
    } |
    
//|	<tINT2CHAR> <tPAREN_INI> expresion() <tPAREN_FIN>
//|	<tCHAR2INT> <tPAREN_INI> expresion() <tPAREN_FIN>

    // Var, array, func
    t = <tIDENTIFICADOR> {
        s = sf.get_symbol(t);
    }
    term = primario_var_array_func(s) {
        return term;
    }
}

// Desambigua en caso de ser variable, array o función
Attributes primario_var_array_func(Symbol s) : {
    Attributes term;
}
{
    // Función -> El símbolo debe ser función y sus parámetros deben ser correctos
    <tPAREN_INI>
    lista_expresiones()
    <tPAREN_FIN> {
        // TODO
    } |
    term = primario_var_array() {
        return term;
    }		
}

Attributes primario_var_array(Symbol s) {
    Attributes term;
} {


    array() {

    }| 

}


void operador_logico(): {}
{
    <tOR> | <tAND>
}

void operador_relacional() : {} 
{
    <tIGUAL> | <tDISTINTO> | <tMENOR> | <tMENOR_IGUAL> | <tMAYOR> | <tMAYOR_IGUAL>
}

void operador_suma() : {}
{
    <tSUMA> | <tRESTA>
}

void operador_multi() : {}
{
    <tMULTI> | <tDIV> | <tMODULO>
}




// // Una guarda para una condición
// void guarda() : {}
// {
//     <tPAREN_INI> expresion() <tPAREN_FIN>
// }

// // Instrucciones dentro de una llave
// void bloque_interior() : {}
// {
//     <tLLAVE_INI> ( instruccion() )* <tLLAVE_FIN>
// }

// void instruccion() : {}
// {
//     declaracion_variable_local()
// |   una_instruccion() <tPUNTO_COMA>
// |	bloque_condicional()
// |   bloque_bucle()
// }

// void declaracion_variable_local() : {}
// {
//     tipo() <tIDENTIFICADOR> declaracion_variable()
// }

// // Instrucciones que no forman un bloque de código (acaban en ;)
// void una_instruccion() : {}
// {
//     instruccion_integrada()
// |   <tRETURN> expresion()                           // Return
// |   <tIDENTIFICADOR> instr_asignacion_llamada()     // Asignación/llamada
// }

// // Desambigua si es una instrucción de asignación o de invocación
// void instr_asignacion_llamada() : {}
// {
//     ( var_array() )?  <tASIGNAR> expresion()             // Asignación
// |	<tPAREN_INI> lista_expresiones() <tPAREN_FIN>	// Llamada
// }

// // Instrucciones integradas
// void instruccion_integrada() : {}
// {
//     instr_read()                                    // Funciones integradas
// |   instr_read_ln()
// |   instr_print()
// |   instr_print_ln()
// |   instr_int2char()
// |   instr_char2int()       
// }

// void instr_read() : {}
// {
//     <tREAD> <tPAREN_INI> lista_expresiones_cont() <tPAREN_FIN> 
// }

// void instr_read_ln() : {}
// {
//     <tREAD_LN> <tPAREN_INI> lista_expresiones() <tPAREN_FIN> 
// }

// void instr_print() : {}
// {
//     <tPRINT> <tPAREN_INI> lista_expresiones_cont() <tPAREN_FIN> 
// }

// void instr_print_ln() : {}
// {
//     <tPRINT_LN> <tPAREN_INI> lista_expresiones() <tPAREN_FIN> 
// }

// void instr_int2char() : {}
// {
//     <tINT2CHAR> <tPAREN_INI> expresion() <tPAREN_FIN> 
// }

// void instr_char2int() : {}
// {
//     <tCHAR2INT> <tPAREN_INI> expresion() <tPAREN_FIN> 
// }

// /* --- INSTRUCCIONES BLOQUE --- */

// // Un bloque de código condicional
// void bloque_condicional() : {}
// {
//     <tIF> guarda() bloque_interior()			// Condición inicial
//     ( <tELSE> bloque_interior() )?		// Puede continuar tras un else
// }

// // Un bloque de código en un búcle
// void bloque_bucle() : {}
// {
//     <tWHILE> guarda() bloque_interior()
// }

// /* --- CÁLCULO DE EXPRESIONES --- */


