//*****************************************************************
// File:   clike.jj
// Author: Wozniak, Dorian Boleslaw (817570@unizar.es)
// Date:   7/03/2023
// Coms:   compilar mediante "ant". Solo implementa análisis léxico
//*****************************************************************

options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
 	// DEBUG_PARSER = true;
 	// ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

public class clike {
    public static void main(String[] args) {
    	clike parser = null;
    	
    	try {
	    	if(args.length == 0) {
				parser = new clike(System.in);
			}
			else {
	            parser = new clike(new java.io.FileInputStream(args[0]));
			}
			//Programa es el símbolo inicial de la gramática
			parser.Programa();
			System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("ERROR LÉXICO: " + e.getMessage());
        } 
		catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
    }

	public static void printToken(String s, Token t) {
		System.out.printf("(%d,%d): %s \"%s\"\n", t.beginLine, t.beginColumn, s, t.image);
	}
}
PARSER_END(clike)

TOKEN : {
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
}

TOKEN : {

	/* --- PALABRAS RESERVADAS --- */

	// Tipos de datos básicos
	< tBOOL: "bool" > { clike.printToken("palabra reservada", matchedToken); }

|	< tCHAR: "char" > { clike.printToken("palabra reservada", matchedToken); }

| 	< tINT: "int" >	{ clike.printToken("palabra reservada", matchedToken); }

|	< tVOID: "void" > { clike.printToken("palabra reservada", matchedToken); }

	// Condicionales
| 	< tIF: "if"> { clike.printToken("palabra reservada", matchedToken); }
	
|	< tELSE: "else" > { clike.printToken("palabra reservada", matchedToken); }

	// Bucles	
| 	< tWHILE : "while" > { clike.printToken("palabra reservada", matchedToken); }

	// Regreso
| 	< tRETURN : "return"> { clike.printToken("palabra reservada", matchedToken); }

	/* --- DELIMITADORES --- */

	// Paréntesis (guardas if/while, parametros funciones, expresiones...)
|	< tPAREN_INI: "(" > { clike.printToken("apertura de paréntesis", matchedToken); }

|	< tPAREN_FIN : ")" > { clike.printToken("cierre de paréntesis", matchedToken); }

	// Llaves (delimitadores bloques)
| 	< tLLAVE_INI : "{" > { clike.printToken("apertura de llave", matchedToken); }

| 	< tLLAVE_FIN : "}" > { clike.printToken("cierre de llave", matchedToken); }

	// Corchetes (vectores)
| 	< tCORCH_INI : "[" > { clike.printToken("apertura de corchete", matchedToken); }

| 	< tCORCH_FIN : "]" > { clike.printToken("cierre de corchete", matchedToken); }

	// Separador de variables 
|	< tCOMA : "," > { clike.printToken("separador de argumentos", matchedToken); }
	
	// Fin de órden
|	< tPUNTO_COMA : ";" > { clike.printToken("fin de instrucción", matchedToken); }
	
	/* --- OPERADORES --- */

	// Asignación
|	< tASIGNAR : "=" > { clike.printToken("operador asignación", matchedToken); }
	
	// Aritmética
|	< tSUMA : "+" > { clike.printToken("operador suma", matchedToken); }

|	< tRESTA : "-" > { clike.printToken("operador resta", matchedToken); }

|	< tMULTI : "*" > { clike.printToken("operador multiplicación", matchedToken); }

|	< tDIV : "/" > { clike.printToken("operador división", matchedToken); }

|	< tMODULO : "%" > { clike.printToken("operador módulo", matchedToken); }

	// Lógica 
|	< tMAYOR : ">" > { clike.printToken("operador mayor", matchedToken); }

|	< tMENOR : "<" > { clike.printToken("operador menor", matchedToken); }

|	< tMAYOR_IGUAL: ">=" >	{ clike.printToken("operador menor o igual", matchedToken); }

|	< tMENOR_IGUAL : "<=" > { clike.printToken("operador menor o igual", matchedToken); }

|	< tIGUAL : "==" > { clike.printToken("operador igualdad", matchedToken); }

|	< tDISTINTO : "<>" > { clike.printToken("operador no igualdad", matchedToken); }

| 	< tAND : "&&" > { clike.printToken("operador AND", matchedToken); }

| 	< tOR : "||" >  { clike.printToken("operador OR", matchedToken); }

| 	< tNOT : "!" >  { clike.printToken("operador NOT", matchedToken); }

	// Referencia
|	< tAMPERSAND : "&" > { clike.printToken("operador referencia", matchedToken); }

	/* --- IDENTIFICADORES --- */

|	< tIDENTIFICADOR : ( < LETTER > | "_")( < LETTER > | < DIGIT > | "_" )* > { 
		clike.printToken("identificador", matchedToken); 
	}

	/* --- CONSTANTES SIMBÓLICAS --- */

|	< tCONST_CHAR : "'"(~[])"'" > {
		clike.printToken("constante carácter", matchedToken);
	}

|	< tCONST_STRING : "\""(~["\""] | "\"\"")*"\"" > {
		clike.printToken("constante cadena", matchedToken);
	}

|	< tCONST_NUM : ((< DIGIT >)+ ) > {
		clike.printToken("constante numérica", matchedToken);
	}

|	< tTRUE : "true" > {
		clike.printToken("constante booleana", matchedToken);
	}

|	< tFALSE : "false" > {
		clike.printToken("constante booleana", matchedToken);
	}
}

SKIP : {
	" " | "\t" | "\n" 						// Espacios en blanco
	| <tCOMENTARIO : ("//"(~["\n"])+) > 	// Comentarios
}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() : 
{
	Token t;
}
{
	( 
		<tBOOL> | <tCHAR> | <tINT> | <tVOID> |
		<tIF> | <tELSE> | <tWHILE> | <tRETURN> |
		<tPAREN_INI> | <tPAREN_FIN> | <tLLAVE_INI> | <tLLAVE_FIN> |
		<tCOMA> | <tPUNTO_COMA> | 
		<tASIGNAR> | <tSUMA> | <tRESTA> | <tMULTI> | <tDIV> | <tMODULO> |
		<tMAYOR> | <tMAYOR_IGUAL> | <tMENOR> | <tMENOR_IGUAL> |
		<tIGUAL> | <tDISTINTO> | <tAND> | <tOR> | <tNOT> |
		<tCORCH_INI> | <tCORCH_FIN> |
		<tIDENTIFICADOR> | <tCONST_NUM> | <tCONST_CHAR> | <tCONST_STRING> |
		 <tTRUE> | <tFALSE> | <tAMPERSAND>

		
	)+
	< EOF > { }
}
