options {
    IGNORE_CASE = false;
    COMMON_TOKEN_ACTION = false;
    //DEBUG_PARSER = true;
    // ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;

import java.util.ArrayList;

public class clike {

    // Lista de palabras reservadas
    private static String[] reservadas = {
        "INT",
        "BOOL",
        "CHAR",
        "VOID",
        
        "IF",
        "ELSE",
        "WHILE",

        "RETURN"
    };

    // Tabla de símbolos
    public static SymbolTable st = new SymbolTable(reservadas);

    public static SemanticFunctions sf = new SemanticFunctions(st);

    public static void main(String[] args) {
        clike parser = null;
        
        try {
            if (args.length == 0) {
                parser = new clike(System.in);
            }
            else {
                parser = new clike(new java.io.FileInputStream(args[0]));
            }
            //Programa es el símbolo inicial de la gramática
            parser.Programa();
            System.out.println("***** Análisis terminado con éxito *****");
        }
        catch (java.io.FileNotFoundException e) {
            System.err.println ("Fichero " + args[0] + " no encontrado.");
        }
        catch (TokenMgrError e) {
            System.err.println("ERROR LÉXICO: " + e.getMessage());
        } 
        catch (ParseException e) {
            System.err.println("PARSER_ERROR: " + e.getMessage());
        }
    }
}
PARSER_END(clike)

/* ***** ANALIZADOR LÉXICO ***** */


// Tokens internos
TOKEN : { 
    < #LETTER: (["a"-"z","A"-"Z"]) > | 
    < #DIGIT: ["0"-"9"] > 
}

// Tokens generados
TOKEN : {

    /* --- PALABRAS RESERVADAS --- */

    // Tipos de datos básicos
    < tBOOL: "bool" > |
    < tCHAR: "char" > | 	
    < tINT: "int" > |
    < tVOID: "void" > |

    // Condicionales 	
    < tIF: "if"> |	
    < tELSE: "else" > |

    // Bucles	 	
    < tWHILE : "while" > |

    // Regreso
 	< tRETURN : "return"> |

    /* --- DELIMITADORES --- */

    // Paréntesis (guardas if/while, parametros funciones, expresiones...)
	< tPAREN_INI: "(" >

|	< tPAREN_FIN : ")" >

    // Llaves (delimitadores bloques)
| 	< tLLAVE_INI : "{" >

| 	< tLLAVE_FIN : "}" >

    // Corchetes (vectores)
| 	< tCORCH_INI : "[" >

| 	< tCORCH_FIN : "]" >

    // Separador de variables 
|	< tCOMA : "," > 
    
    // Fin de órden
|	< tPUNTO_COMA : ";" > 
    
    /* --- OPERADORES --- */

    // Asignación
|	< tASIGNAR : "=" > 
    
    // Aritmética
|	< tSUMA : "+" >

|	< tRESTA : "-" >

|	< tMULTI : "*" >

|	< tDIV : "/" >

|	< tMODULO : "%" >

    // Lógica 
|	< tMAYOR : ">" >

|	< tMENOR : "<" >

|	< tMAYOR_IGUAL: ">=" >

|	< tMENOR_IGUAL : "<=" >

|	< tIGUAL : "==" >

|	< tDISTINTO : "!=" >

| 	< tAND : "&&" >

| 	< tOR : "||" >

| 	< tNOT : "!" >

    // Referencia
|	< tAMPERSAND : "&" >

    /* --- FUNCIONES INTEGRADAS --- */

|	< tPRINT : "print" >

|	< tPRINT_LN : "print_ln" >

|	< tREAD : "read" >

|	< tREAD_LN : "read_ln" >

|	< tINT2CHAR : "int2char" >

|	< tCHAR2INT : "char2int" >

    /* --- IDENTIFICADORES --- */

|	< tIDENTIFICADOR : ( < LETTER > | "_")( < LETTER > | < DIGIT > | "_" )* >

    /* --- CONSTANTES SIMBÓLICAS --- */

|	< tCONST_CHAR : "'"(~[])"'" >

|	< tCONST_STRING : "\""(~["\""] | "\"\"")*"\"" >

|	< tCONST_NUM : ((< DIGIT >)+ ) >

|	< tTRUE : "true" >

|	< tFALSE : "false" > 
}

// Expresiones a ignorar
SKIP : {
    " " | "\t" | "\n" 						// Espacios en blanco
    | <tCOMENTARIO : ("//"(~["\n"])*) > 	// Comentarios
}

Token operador_logico(): {
    Token t;
} {
    ( 
        t = <tOR> | 
        t = <tAND> 
    ) { 
        return t; 
    }
}

Token operador_relacional() : {
    Token t;
} {
    (
        t = <tIGUAL> | 
        t = <tDISTINTO> | 
        t = <tMENOR> | 
        t = <tMENOR_IGUAL> | 
        t = <tMAYOR> | 
        t = <tMAYOR_IGUAL>
    ) { 
        return t;
    }
}

Token operador_suma() : {
    Token t;
}{
    (
        t = <tSUMA> |
        t = <tRESTA>
    ) {
        return t;
    }
}

Token operador_multi() : {
    Token t;
} {
    (
        t = <tMULTI> | 
        t = <tDIV> | 
        t = <tMODULO>
    ) {
        return t;
    }
}


// Expresión -> Prioridad 7

void expresion(Attributes at) : {
    Attributes at1, at2;
}
{
    // Sin expresiones lógicas -> Cualquier tipo
    relacion_aritmetica(at1) {
        at = at1;
    }
    // Con expresiones lógicas -> Solo booleanos
    ( 
        relacion_logica(at2) {

        }
    )?
}

// Relación lógica -> Prioridad 6 (comparaciones lógicas)
void relacion_logica(Attributes at) : {
    Attributes at1;
    Token t;
}
{
    // Solo booleanos
    ( 
        t = operador_logico() 
        relacion_aritmetica(at1) {
            sf.relacion_logica(t, at, at1);
        }
    )+
}

// Relación aritmética -> Prioridad 5 (comparaciones aritméticas)
void relacion_aritmetica(Attributes at) : {
    Attributes at1, at2;
    Token t;
}
{
    // Sin operador -> cualquier tipo
    expresion_simple(at1) {
        at = at1;
    }
    // Con operador -> Solo datos del mismo tipo
    ( 
        t = operador_relacional() 
        expresion_simple(at2) {
            sf.relacion_aritmetica(t, at, at1, at2);
        } 
    )?
}

// Expresión simple -> Prioridad 4 (suma/resta)
void expresion_simple(Attributes at) : {
    Attributes at1, at2;
}
{
    // Con prefijo -> Solo enteros
    (
        operador_suma() {
        }
    )? 
    // Sin prefijo -> Cualquier tipo
    termino(at1) {
        at = at1;
    }
    // Con operador -> Solo enteros
    ( 
        operador_suma()
        termino(at2) {
            if (at1.type == Symbol.Types.INT && at2.type == Symbol.Types.INT) {
                
            } else {
                at.type = Symbol.Types.UNDEFINED;
            }
        }
    )*
}

// Término -> Prioridad 3 (multiplicación/división/módulo)
void termino(Attributes at) :  {
    Attributes at1, at2;
}
{
    // Sin operador -> Cualquier tipo
    factor(at1) {
        at = at1;
    }
    // Con operador -> Solo enteros
    ( 
        operador_multi() 
        factor(at2) {
            if (at1.type == Symbol.Types.INT && at2.type == Symbol.TYPES.INT) {
                // TODO: Tratamiento de expresiones
            } else {
                at.type = Symbol.Types.UNDEFINED;
            }
        }
    )*
}

// Factor -> Prioridad 2 (negación)
void factor(Attributes at) : {
    Attributes at1;
}
{
    // Sin negación -> Cualquier tipo
    primario(at1) {
        at1 = at;
    } | 
    // Con negación -> Solo booleanos
    <tNOT> primario(at1) {
        if (at1.type == Symbol.Types.BOOL) {
            // TODO: Tratamiento de expresion
        } else {
            at.type = Symbol.Types.UNDEFINED;
        }
    }
}

// Primario -> Prioridad 1
void primario(Attributes at) : {
    Attributes at1;
    Token t;
    Symbol s;
} 
{
    // Paréntesis
    <tPAREN_INI> 
    expresion(at1)
    <tPAREN_FIN> {
        at = at1;
    } |
    // Constantes
 	t = <tCONST_NUM> {
        at.type = Symbol.Types.INT;
        at.isConst = true;
        at.valInt = Integer.parseInt(t.image);
    } |								
	t = <tCONST_CHAR> {
        at.type = Symbol.Types.CHAR;
        at.isConst = true;
        at.valChar = t.image[0]; 
    } |
	t = <tCONST_STRING> { 
        at.type = Symbol.Types.STRING;
        at.isConst = true;mbol.Types.BOOL;
        at.isConst = true;
        at.valBool = true;
    } |
	t = <tFALSE> { 
        at.type = Symbol.Types.BOOL;
        at.isConst = true;
        at.valBool = false;
    } |
        at.valChar = t.image; 
    } |
	t = <tTRUE> {
        at.type = Symbol.Types.BOOL;
        at.isConst = true;
        at.valBool = true;
    } |
	t = <tFALSE> { 
        at.type = Symbol.Types.BOOL;
        at.isConst = true;
        at.valBool = false;
    } |
	// <tINT2CHAR> <tPAREN_INI> expresion() <tPAREN_FIN> |
	// <tCHAR2INT> <tPAREN_INI> expresion() <tPAREN_FIN> |
    // Var, array, func
	t = <tIDENTIFICADOR> {
        // El identificador debe existir
        try {
            s = st.getSymbol(t.image)
        } catch (SymbolNotFoundException e) {
            // TODO: Tratamiento de error
        }
    }
    primario_var_array_func(t, at1) {

    }
}

// Desambigua en caso de ser variable, array o función
void primario_var_array_func(Attributes at) : {}
{
    // Función
    <tPAREN_INI>
    lista_expresiones()
    <tPAREN_FIN> |

    // Elemento de array
	<tCORCH_INI> 
    expresion() 
    <tCORCH_FIN> {

    } |			
    // Vacío - Variable
 	/* Épsilon */ { 

    }								
}